<!doctype html>
<html lang="es">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Chat ‚Äî Optimizado</title>

    <!-- Firebase SDK (modular) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // --- Pega tu config aqu√≠ si quieres cambiar ---
        const firebaseConfig = {
            apiKey: "AIzaSyDB8Ffk2v4SzHpuSdAtwBo9mMk7d-FVoEk",
            authDomain: "again-39689.firebaseapp.com",
            projectId: "again-39689",
            storageBucket: "again-39689.firebasestorage.app",
            messagingSenderId: "777451941392",
            appId: "1:777451941392:web:1e2ffbb0817a0c5019a495",
            measurementId: "G-6P2YR4RLFJ"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        window.__FIRE = { db };
    </script>

    <style>
        /* (estilos compactados, copia los tuyos o usa los previos) */
        :root {
            --side-width: 320px;
            --muted: #94a3b8;
            --accent: #7dd3fc
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: Inter, system-ui, Arial;
            background: #04060a;
            color: #e6eef8;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
            min-height: 100vh
        }

        .card {
            width: 100%;
            max-width: 1100px;
            border-radius: 14px;
            overflow: hidden;
            display: flex;
            gap: 1px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
            min-height: 560px;
            max-height: 90vh
        }

        .panel-left {
            width: var(--side-width);
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: rgba(255, 255, 255, 0.02)
        }

        .rooms-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 40vh;
            overflow: auto;
            padding-right: 6px
        }

        .room-item {
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
            color: var(--muted);
            border: 1px solid rgba(255, 255, 255, 0.02)
        }

        .room-item.active {
            background: linear-gradient(90deg, rgba(125, 211, 252, 0.06), rgba(125, 211, 252, 0.02));
            color: var(--accent);
            font-weight: 700;
            border-color: rgba(125, 211, 252, 0.12)
        }

        .panel-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: linear-gradient(180deg, #001 0%, #032 100%);
            position: relative
        }

        .header {
            padding: 14px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03)
        }

        .messages {
            padding: 18px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow: auto;
            flex: 1;
            min-height: 220px;
            max-height: calc(90vh - 240px)
        }

        .composer {
            display: flex;
            gap: 8px;
            padding: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.02);
            align-items: center
        }

        .composer input {
            flex: 1;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.03);
            background: rgba(255, 255, 255, 0.02);
            color: inherit
        }

        .btn-send {
            padding: 10px 14px;
            border-radius: 10px;
            border: none;
            background: linear-gradient(90deg, #06b6d4, #38bdf8);
            color: #042431;
            font-weight: 700;
            cursor: pointer
        }

        .btn-ico {
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            background: transparent;
            color: var(--muted);
            cursor: pointer
        }

        .msg {
            max-width: 74%;
            padding: 10px 12px;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.3;
            display: flex;
            gap: 8px;
            align-items: flex-start;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4)
        }

        .msg.daniel {
            align-self: flex-end;
            background: rgba(189, 61, 78, 0.41);
            flex-direction: row-reverse;
            color: #fff
        }

        .msg.leidy {
            align-self: flex-start;
            background: #252a36;
            color: #e6eef8
        }

        .bubble-avatar {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            overflow: hidden;
            flex-shrink: 0;
            border: 2px solid rgba(255, 255, 255, 0.06)
        }

        .bubble-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover
        }

        .bubble-content {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-width: 100%
        }

        .bubble-text {
            white-space: pre-wrap;
            word-break: break-word
        }

        .bubble-image {
            width: 220px;
            max-width: 100%;
            border-radius: 12px;
            margin-top: 6px
        }

        .sticker-panel {
            position: absolute;
            left: calc(var(--side-width)+12px);
            bottom: 72px;
            right: 20px;
            max-height: 220px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 10px;
            display: none;
            overflow: auto;
            z-index: 50
        }

        .sticker-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px
        }

        .sticker-item {
            width: 64px;
            height: 64px;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer
        }

        .msg-menu {
            position: absolute;
            background: #111;
            border: 1px solid #333;
            padding: 4px;
            display: none;
            flex-direction: row;
            gap: 4px;
            border-radius: 12px;
            z-index: 9999
        }

        .reply-box {
            padding: 6px;
            font-size: 12px;
            opacity: 0.9;
            border-left: 3px solid #00b3ff;
            margin-bottom: 4px
        }

        .reaction {
            font-size: 16px;
            margin-top: 4px
        }

        .load-more {
            margin: 8px auto;
            padding: 6px 10px;
            background: #111;
            border-radius: 8px;
            cursor: pointer
        }

        @media (max-width:720px) {
            .panel-left {
                display: none
            }
        }
    </style>
</head>

<body>
    <div id="msgMenu" class="msg-menu" aria-hidden="true">
        <div class="menu-item" data-react="‚ù§Ô∏è">‚ù§Ô∏è</div>
        <div class="menu-item" data-react="üëç">üëç</div>
        <div class="menu-item" data-react="üòÇ">üòÇ</div>
        <div class="menu-item" data-react="üî•">üî•</div>
        <div class="menu-item" data-action="reply">üí¨ Responder</div>
    </div>

    <div class="card" id="appCard">
        <div class="panel-left">
            <div style="display:flex;justify-content:space-between;align-items:center">
                <div style="font-weight:700">Salas</div>
                <button id="btnNewRoom" class="new-room-btn">+ Nuevo chat</button>
            </div>
            <div class="rooms-list" id="roomsList"></div>
            <div style="margin-top:auto" class="meta">Perfil activo: <span id="activeName" class="small">‚Äî</span></div>
        </div>

        <div class="panel-right">
            <div class="header">
                <div style="display:flex;gap:12px;align-items:center">
                    <!-- header avatar ahora con lazy + decoding -->
                    <div class="avatar"><img src="daniel.jpg" id="headerAvatarImg" loading="lazy" decoding="async"
                            style="width:52px;height:52px;object-fit:cover" onerror="this.style.display='none'"></div>
                    <div>
                        <div id="chatTitle" class="chat-title">Selecciona una sala</div>
                        <div id="chatSub" class="chat-sub">Inicia sesi√≥n</div>
                    </div>
                </div>
                <div><small class="small">Chat </small></div>
            </div>

            <div id="messages" class="messages" aria-live="polite"></div>
            <div id="loadMore" class="load-more" style="display:none">‚¨Ü Cargar m√°s historial</div>

            <div class="sticker-panel" id="stickerPanel" aria-hidden="true">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                    <div style="font-weight:700">Stickers</div><button id="closeStickers"
                        style="background:transparent;border:none;color:var(--muted);cursor:pointer">Cerrar</button>
                </div>
                <div class="sticker-grid" id="stickerGrid"></div>
            </div>

            <form id="composer" class="composer" onsubmit="return false;" style="display:none">
                <input id="msgInput" placeholder="Escribe un mensaje..." autocomplete="off" />
                <button id="btnRecord" class="btn-ico" type="button" title="Grabar audio">üé§</button>
                <button id="btnSticker" class="btn-ico" type="button" title="Stickers">üü°</button>
                <button id="btnImage" class="btn-ico" type="button" title="Enviar imagen">üñºÔ∏è</button>
                <input type="file" id="imageInput" accept="image/*" style="display:none">
                <button id="sendBtn" class="btn-send">Enviar</button>
            </form>
        </div>
    </div>

    <div class="overlay" id="loginOverlay"
        style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:60">
        <div
            style="background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:20px;border-radius:12px;width:100%;max-width:420px;">
            <h2>Acceso al chat</h2>
            <div style="display:flex;gap:8px">
                <input id="passwordInput" placeholder="Contrase√±a secreta"
                    style="flex:1;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);background:rgba(255,255,255,0.02);color:inherit" />
                <button id="loginBtn" class="btn-send">Entrar</button>
            </div>
        </div>
    </div>

    <script>
        (function () {
            // ------------- CONFIG -------------
            const CACHE_LIMIT = 5000;            // mensajes por sala a mantener en local (ajusta si quieres m√°s)
            const PAGE_SIZE = 40;                // cu√°ntos mensajes trae cada "cargar m√°s"
            const DEBOUNCE_MS = 400;             // agrupa env√≠os r√°pidos
            const STICKERS = ["pollo.png", "sticker1.png", "sticker2.webp", "sticker3.webp", "sticker4.webp", "sticker5.webp", "sticker6.webp", "sticker7.webp", "sticker9.webp", "hey-floppa.webp", "no-no-cat.webp"];

            // DOM
            const loginOverlay = document.getElementById('loginOverlay');
            const passwordInput = document.getElementById('passwordInput');
            const loginBtn = document.getElementById('loginBtn');
            const activeNameEl = document.getElementById('activeName');
            const headerAvatarImg = document.getElementById('headerAvatarImg');
            const messagesEl = document.getElementById('messages');
            const composer = document.getElementById('composer');
            const msgInput = document.getElementById('msgInput');
            const sendBtn = document.getElementById('sendBtn');

            const btnRecord = document.getElementById('btnRecord');
            const btnSticker = document.getElementById('btnSticker');
            const stickerPanel = document.getElementById('stickerPanel');
            const stickerGrid = document.getElementById('stickerGrid');
            const closeStickers = document.getElementById('closeStickers');

            const btnImage = document.getElementById('btnImage');
            const imageInput = document.getElementById('imageInput');

            const roomsListEl = document.getElementById('roomsList');
            const btnNewRoom = document.getElementById('btnNewRoom');
            const loadMoreBtn = document.getElementById('loadMore');
            const msgMenu = document.getElementById('msgMenu');

            // state
            const accessKeys = { "marzo10": "leidy", "enero10": "daniel" };
            let currentUser = null;
            let currentRoomId = null;
            let unsubscribeNewMessages = null;    // listener only for new msgs
            let oldestLoadedDoc = null;           // for pagination older
            let newestTimestamp = 0;              // time of last message we have
            let recorder = null, audioChunks = [];
            let replyTo = null;
            let sendTimer = null;

            // Fire helpers
            function fire() { return window.__FIRE && window.__FIRE.db ? window.__FIRE : null; }
            function esc(s = '') { return String(s).replace(/[&<>"']/g, t => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[t])); }

            // ----------------- Local cache utilities -----------------
            function cacheKey(roomId) { return 'chat_cache_' + roomId; }
            function loadCache(roomId) {
                try {
                    const raw = localStorage.getItem(cacheKey(roomId));
                    return raw ? JSON.parse(raw) : { msgs: [], newest: 0 };
                } catch (e) { return { msgs: [], newest: 0 }; }
            }
            function saveCache(roomId, cache) {
                try {
                    // keep only last CACHE_LIMIT messages
                    if (cache.msgs.length > CACHE_LIMIT) cache.msgs = cache.msgs.slice(-CACHE_LIMIT);
                    localStorage.setItem(cacheKey(roomId), JSON.stringify(cache));
                } catch (e) { }
            }

            // ----------------- Login -----------------
            loginBtn.addEventListener('click', tryLogin);
            passwordInput.addEventListener('keydown', e => { if (e.key === 'Enter') tryLogin(); });

            function tryLogin() {
                const pass = passwordInput.value.trim();
                if (!pass) return alert('Escribe la contrase√±a.');
                const name = accessKeys[pass];
                if (!name) return alert('Contrase√±a incorrecta.');
                currentUser = name;
                headerAvatarImg.src = (currentUser === 'daniel') ? 'daniel.jpg' : 'leidy.jpg';
                activeNameEl.textContent = currentUser.charAt(0).toUpperCase() + currentUser.slice(1);
                composer.style.display = 'flex';
                loginOverlay.style.display = 'none';
                initRooms();
                loadStickers();
            }

            // --------------- Stickers ---------------
            function loadStickers() {
                stickerGrid.innerHTML = '';
                STICKERS.forEach(s => {
                    const item = document.createElement('div'); item.className = 'sticker-item';
                    const img = document.createElement('img'); img.src = 'stickers/' + s; img.loading = 'lazy'; img.decoding = 'async';
                    item.appendChild(img);
                    item.addEventListener('click', async () => { await sendMessage({ sticker: img.src }); hideStickers(); });
                    stickerGrid.appendChild(item);
                });
            }
            btnSticker.addEventListener('click', (e) => { e.preventDefault(); toggleStickers(); });
            closeStickers.addEventListener('click', hideStickers);
            function toggleStickers() { stickerPanel.style.display = (stickerPanel.style.display === 'block') ? 'none' : 'block'; }
            function showStickers() { stickerPanel.style.display = 'block'; }
            function hideStickers() { stickerPanel.style.display = 'none'; }

            // --------------- Image upload ---------------
            btnImage.addEventListener('click', () => imageInput.click());
            imageInput.addEventListener('change', () => {
                const file = imageInput.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onloadend = async () => { await sendMessage({ image: reader.result }); imageInput.value = ''; };
                reader.readAsDataURL(file);
            });

            // --------------- Audio recording ---------------
            btnRecord.addEventListener('click', async (e) => { e.preventDefault(); if (recorder && recorder.state === 'recording') stopRecording(); else await startRecording(); });
            async function startRecording() {
                if (!currentUser || !currentRoomId) { alert('Entra a una sala antes de grabar.'); return; }
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    recorder = new MediaRecorder(stream);
                    audioChunks = [];
                    recorder.ondataavailable = e => { if (e.data && e.data.size) audioChunks.push(e.data); };
                    recorder.onstop = async () => {
                        const blob = new Blob(audioChunks, { type: audioChunks[0]?.type || 'audio/webm' });
                        if (blob.size > 1024 * 1024 * 0.9) { alert('Audio muy grande, hazlo m√°s corto.'); return; }
                        const reader = new FileReader();
                        reader.onloadend = async () => { await sendMessage({ audio: reader.result, mime: blob.type }); };
                        reader.readAsDataURL(blob);
                        try { stream.getTracks().forEach(t => t.stop()); } catch (e) { }
                    };
                    recorder.start();
                    btnRecord.textContent = '‚èπÔ∏è Grabando...';
                    setTimeout(() => { if (recorder && recorder.state === 'recording') stopRecording(); }, 20000);
                } catch (e) { console.error(e); alert('No se pudo acceder al micr√≥fono.'); }
            }
            function stopRecording() { if (recorder && recorder.state === 'recording') recorder.stop(); recorder = null; btnRecord.textContent = 'üé§'; }

            // --------------- Rooms (light) ---------------
            async function initRooms() {
                // For simplicity: we listen to chat_rooms collection but only once to render list.
                await ensureFireReady();
                const db = fire().db;
                // lightweight get: not a continuous listener (reduces reads)
                try {
                    const col = await (await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js")).getDocs((await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js")).collection(db, 'chat_rooms'));
                    const rooms = col.docs.map(d => ({ id: d.id, ...d.data() }));
                    if (rooms.length === 0) {
                        // create default general (one-time write)
                        await (await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js")).addDoc((await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js")).collection(db, 'chat_rooms'), { name: 'General', createdAt: Date.now() });
                        return initRooms();
                    }
                    renderRoomsList(rooms);
                    if (!currentRoomId) selectRoom(rooms[0].id, rooms[0].name);
                } catch (e) {
                    console.error('initRooms failed', e);
                    // fallback: create UI minimal rooms if rules block getDocs
                    renderRoomsList([{ id: 'general', name: 'General' }]);
                    if (!currentRoomId) selectRoom('general', 'General');
                }
            }

            function renderRoomsList(list) {
                roomsListEl.innerHTML = '';
                list.forEach(r => {
                    const el = document.createElement('div'); el.className = 'room-item'; el.dataset.roomId = r.id; el.textContent = r.name || 'Sala';
                    el.addEventListener('click', () => selectRoom(r.id, r.name));
                    roomsListEl.appendChild(el);
                });
            }
            btnNewRoom.addEventListener('click', async () => { const n = prompt('Nombre sala:'); if (!n) return; await createRoom(n); });

            async function createRoom(name) {
                await ensureFireReady();
                const fs = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
                const { collection, addDoc } = fs;
                try { await addDoc(collection(fire().db, 'chat_rooms'), { name, createdAt: Date.now() }); }
                catch (e) { console.error('createRoom error', e); alert('Error creando sala'); }
            }

            // --------------- Message sync strategy ---------------
            // Load from cache (immediate), render, then:
            // - fetch latest PAGE_SIZE from Firestore (if newer than cache.newest)
            // - set a small real-time listener for only messages with time > newest (new messages)
            // - oldestLoadedDoc stores cursor for "load more" older messages (descending queries)

            
            
            // Merge messages arrays by id, preserving order (ascending time)
            function mergeMessages(oldArr, newArr) {
                const map = new Map();
                oldArr.forEach(m => map.set(m.id, m));
                newArr.forEach(m => map.set(m.id, m));
                // return sorted by time asc
                return Array.from(map.values()).sort((a, b) => (a.time || 0) - (b.time || 0));
            }

            // append new messages (from listener)
            

            // Load older messages (pagination)
            loadMoreBtn.addEventListener('click', async () => {
                await loadOlderPage();
            });

            async function loadOlderPage() {
                if (!currentRoomId) return;
                await ensureFireReady();
                const fs = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
                const { collection, query, orderBy, limit, getDocs, startAfter } = fs;
                const msgsRef = collection(fire().db, `chat_rooms/${currentRoomId}/messages`);
                try {
                    // If we have an oldestLoadedDoc snapshot, query older than that by ordering desc and startAfter
                    // Simpler fallback: query orderBy('time','desc'), limit(PAGE_SIZE), and skip ones we already have by comparing time
                    const qOlder = query(msgsRef, orderBy('time', 'desc'), limit(PAGE_SIZE));
                    const snap = await getDocs(qOlder);
                    if (snap.empty) return;
                    // docs are newest->oldest; reverse to oldest->newest
                    const docs = snap.docs;
                    docs.reverse();
                    const msgs = docs.map(d => ({ id: d.id, ...d.data() }));
                    // merge preserving order
                    const cache = loadCache(currentRoomId);
                    const merged = mergeMessages(msgs.concat(cache.msgs), []); // ensure older at front
                    saveCache(currentRoomId, { msgs: merged, newest: cache.newest || newestTimestamp });
                    renderMessages(merged);
                } catch (e) { console.error('loadOlderPage', e); }
            }

            


// ----------------- Cargar √∫ltima p√°gina hist√≥rica si no hay cach√© -----------------
async function loadLatestPageHistory(){
    if(!currentRoomId) return;
    await ensureFireReady();

    const fs = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
    const { collection, query, orderBy, limit, getDocs } = fs;

    const msgsRef = collection(fire().db, `chat_rooms/${currentRoomId}/messages`);
    try{
        const q = query(msgsRef, orderBy('time','desc'), limit(PAGE_SIZE));
        const snap = await getDocs(q);
        if(!snap.empty){
            const docs = snap.docs;
            docs.reverse(); // ordenar ascendente
            const msgs = docs.map(d => ({ id:d.id, ...d.data() }));
            newestTimestamp = msgs[msgs.length-1].time || Date.now();
            oldestLoadedDoc = docs[0];
            // Guardar en cach√© y render
            saveCache(currentRoomId, { msgs, newest: newestTimestamp });
            renderMessages(msgs);
        }
    }catch(e){ console.error('loadLatestPageHistory', e); }
}

// ----------------- Listener para nuevos mensajes -----------------

// ----------------- Seleccionar sala y cargar mensajes -----------------
async function selectRoom(roomId, roomName){
    if(currentRoomId === roomId) return;

    // UI highlight
    const prev = roomsListEl.querySelector('.room-item.active');
    if(prev) prev.classList.remove('active');
    const el = roomsListEl.querySelector(`[data-room-id="${roomId}"]`);
    if(el) el.classList.add('active');

    currentRoomId = roomId;
    document.getElementById('chatTitle').textContent = roomName || 'Sala';
    messagesEl.innerHTML = '';

    // cancelar listener anterior si existe
    cancelNewListener();

    // Cargar cache local
    const cache = loadCache(roomId);
    newestTimestamp = cache.newest || 0;

    if(cache.msgs && cache.msgs.length){
        renderMessages(cache.msgs, { preserveScroll:true });
    } else {
        await loadLatestPageHistory();
    }

    // Iniciar listener en tiempo real para nuevos mensajes
    listenNewMessages();

    // Mostrar composer
    composer.style.display = 'flex';
}

// ----------------- Listener para nuevos mensajes en tiempo real -----------------
async function listenNewMessages(){
    if(!currentRoomId) return;
    await ensureFireReady();
    cancelNewListener();

    const fs = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
    const { collection, query, where, orderBy, onSnapshot } = fs;

    const msgsRef = collection(fire().db, `chat_rooms/${currentRoomId}/messages`);

    // Solo mensajes con time > newestTimestamp
    const qNew = query(msgsRef, where('time', '>', newestTimestamp), orderBy('time'));
    unsubscribeNewMessages = onSnapshot(qNew, snap => {
        if(!snap.empty){
            const newMsgs = snap.docs.map(d => ({ id:d.id, ...d.data() }));
            appendNewMessages(newMsgs);
        }
    }, err => console.error('Listener error:', err));
}

// ----------------- Agregar mensajes nuevos al DOM y cach√© -----------------
function appendNewMessages(newMsgs){
    if(!currentRoomId || !newMsgs || !newMsgs.length) return;

    const cache = loadCache(currentRoomId);
    const existingIds = new Set(cache.msgs.map(m => m.id));

    const filtered = newMsgs.filter(m => !existingIds.has(m.id));
    if(!filtered.length) return;

    // actualizar cach√©
    cache.msgs = cache.msgs.concat(filtered);
    if(cache.msgs.length > CACHE_LIMIT) cache.msgs = cache.msgs.slice(-CACHE_LIMIT);
    cache.newest = Math.max(cache.newest || 0, ...filtered.map(m => m.time || 0));
    saveCache(currentRoomId, cache);

    // render solo los nuevos
    filtered.forEach(m => appendMessageToDOM(m));

    // actualizar timestamp global
    newestTimestamp = cache.newest;
}

// ----------------- Cancelar listener -----------------
function cancelNewListener(){
    try{
        if(unsubscribeNewMessages){
            unsubscribeNewMessages();
            unsubscribeNewMessages = null;
        }
    }catch(e){}
}

// ----------------- Cargar √∫ltima p√°gina hist√≥rica si no hay cach√© -----------------
async function loadLatestPageHistory(){
    if(!currentRoomId) return;
    await ensureFireReady();

    const fs = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
    const { collection, query, orderBy, limit, getDocs } = fs;

    const msgsRef = collection(fire().db, `chat_rooms/${currentRoomId}/messages`);
    try{
        const q = query(msgsRef, orderBy('time','desc'), limit(PAGE_SIZE));
        const snap = await getDocs(q);
        if(!snap.empty){
            const docs = snap.docs;
            docs.reverse(); // ordenar ascendente
            const msgs = docs.map(d => ({ id:d.id, ...d.data() }));
            newestTimestamp = msgs[msgs.length-1].time || Date.now();
            oldestLoadedDoc = docs[0];
            saveCache(currentRoomId, { msgs, newest: newestTimestamp });
            renderMessages(msgs);
        }
    }catch(e){ console.error('loadLatestPageHistory', e); }
}

// ----------------- Cancelar listener -----------------
function cancelNewListener(){
    try{
        if(unsubscribeNewMessages){
            unsubscribeNewMessages();
            unsubscribeNewMessages = null;
        }
    }catch(e){}
}

            

            // disconnect listener when tab hidden
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) { cancelNewListener(); }
                else { if (currentRoomId) loadLatestPageAndListen(); }
            });

            // --------------- Sending messages (debounced) ---------------
            async function sendMessage(extra = {}) {
                if (!currentUser || !currentRoomId) return;
                const text = (msgInput && msgInput.value) ? msgInput.value.trim() : '';
                if (!text && !extra.audio && !extra.sticker && !extra.image) return;

                // debounce writes: if user sends many messages quickly, queue small delay
                if (sendTimer) clearTimeout(sendTimer);
                sendTimer = setTimeout(async () => {
                    await ensureFireReady();
                    const fs = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
                    const { collection, addDoc } = fs;
                    const data = { from: currentUser, time: Date.now(), text: text || '', ...extra };
                    if (replyTo) { data.replyTo = { id: replyTo.id, from: replyTo.from, text: replyTo.text || null }; replyTo = null; if (msgInput) msgInput.placeholder = 'Escribe un mensaje...'; }
                    try {
                        await addDoc(collection(fire().db, `chat_rooms/${currentRoomId}/messages`), data);
                        if (msgInput) msgInput.value = '';
                    } catch (e) { console.error('sendMessage error', e); alert('No se pudo enviar (reglas o cuota)'); }
                }, DEBOUNCE_MS);
            }
            sendBtn.addEventListener('click', e => { e.preventDefault(); sendMessage(); });
            msgInput.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); sendMessage(); } });

            // --------------- Update message (reaction) ---------------
            async function updateMessage(msgId, updateObj) {
                if (!currentRoomId) return;
                await ensureFireReady();
                const fs = await import("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js");
                const { doc, setDoc } = fs;
                try {
                    const ref = doc(fire().db, `chat_rooms/${currentRoomId}/messages`, msgId);
                    await setDoc(ref, updateObj, { merge: true });
                } catch (e) { console.error('updateMessage', e); }
            }

            // --------------- Message menu (reactions/reply) ---------------
            function openMessageMenu(e, msg) {
                e.stopPropagation();
                const pad = 8; const menu = msgMenu;
                menu.style.display = 'flex'; menu.setAttribute('aria-hidden', 'false');
                const vw = window.innerWidth, vh = window.innerHeight;
                let left = e.clientX + pad, top = e.clientY + pad;
                if (left + menu.offsetWidth > vw) left = vw - menu.offsetWidth - pad;
                if (top + menu.offsetHeight > vh) top = vh - menu.offsetHeight - pad;
                menu.style.left = left + 'px'; menu.style.top = top + 'px';

                const handler = async ev => {
                    const react = ev.target.dataset.react; const action = ev.target.dataset.action;
                    if (react) await updateMessage(msg.id, { reaction: react });
                    else if (action === 'reply') { replyTo = msg; if (msgInput) { msgInput.placeholder = `Responder a "${msg.text || 'imagen'}"...`; msgInput.focus(); } }
                    menu.style.display = 'none'; menu.setAttribute('aria-hidden', 'true');
                    document.removeEventListener('click', handler);
                };
                document.addEventListener('click', handler);
            }

            // --------------- Render messages (from cache or fetch) ---------------
            function renderMessages(list, opts = {}) {
                // opts.preserveScroll = if true, don't reset scroll if user was near bottom
                const preserve = !!opts.preserveScroll;
                const atBottom = (messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight) < 150;
                messagesEl.innerHTML = '';
                if (!list || !list.length) {
                    const p = document.createElement('div'); p.className = 'msg leidy'; p.style.maxWidth = '100%'; p.textContent = 'A√∫n no hay mensajes en esta sala.'; messagesEl.appendChild(p); return;
                }
                list.forEach(m => {
                    const div = document.createElement('div'); const cls = (m.from === currentUser) ? 'daniel' : 'leidy'; div.className = 'msg ' + cls;
                    let inner = `<div class="bubble-content">`;
                    inner += `<div class="bubble-name">${esc(m.from || '')}</div>`;
                    if (m.replyTo) inner += `<div class="reply-box">${esc(m.replyTo.from || '')}: ${esc(m.replyTo.text || 'Imagen')}</div>`;
                    if (m.text) inner += `<div class="bubble-text">${esc(m.text)}</div>`;
                    // bubble image now uses loading="lazy" + decoding="async"
                    if (m.image) inner += `<img src="${m.image}" loading="lazy" decoding="async" class="bubble-image" alt="imagen">`;
                    if (m.sticker) inner += `<div><img src="${m.sticker}" loading="lazy" decoding="async" style="width:140px;border-radius:12px"></div>`;
                    if (m.audio) inner += `<div><audio controls preload="none" src="${m.audio}"></audio></div>`;
                    if (m.reaction) inner += `<div class="reaction">${m.reaction}</div>`;
                    inner += `<div class="bubble-meta">${new Date(m.time || Date.now()).toLocaleTimeString()}</div>`;
                    inner += `</div>`;
                    div.innerHTML = (m.from === currentUser) ? inner + avatarTag(m.from) : avatarTag(m.from) + inner;
                    div.addEventListener('click', (e) => {
                        const ignore = ['AUDIO', 'BUTTON', 'A', 'INPUT', 'IMG', 'svg', 'path'];
                        if (ignore.includes(e.target.tagName)) return;
                        openMessageMenu(e, m);
                    });
                    messagesEl.appendChild(div);
                });
                if (preserve && atBottom) messagesEl.scrollTo({ top: messagesEl.scrollHeight, behavior: 'smooth' });
                else if (!preserve) messagesEl.scrollTo({ top: messagesEl.scrollHeight, behavior: 'smooth' });

                // save cache after render (efficient)
                const cache = loadCache(currentRoomId); cache.msgs = list; cache.newest = list.length ? list[list.length - 1].time : cache.newest || 0; saveCache(currentRoomId, cache);

                // show load more if messages length >= PAGE_SIZE (likely there are older)
                loadMoreBtn.style.display = (list.length >= PAGE_SIZE) ? 'block' : 'none';
            }

            function appendMessageToDOM(m) {
                // get cache, append, render last part only (for performance we re-render entire list only rarely)
                const cache = loadCache(currentRoomId);
                cache.msgs.push(m); if (cache.msgs.length > CACHE_LIMIT) cache.msgs = cache.msgs.slice(-CACHE_LIMIT);
                cache.newest = Math.max(cache.newest || 0, m.time || 0);
                saveCache(currentRoomId, cache);
                // append node
                const div = document.createElement('div'); const cls = (m.from === currentUser) ? 'daniel' : 'leidy'; div.className = 'msg ' + cls;
                let inner = `<div class="bubble-content">`;
                inner += `<div class="bubble-name">${esc(m.from || '')}</div>`;
                if (m.text) inner += `<div class="bubble-text">${esc(m.text)}</div>`;
                if (m.image) inner += `<img src="${m.image}" loading="lazy" decoding="async" class="bubble-image" alt="imagen">`;
                if (m.sticker) inner += `<div><img src="${m.sticker}" loading="lazy" decoding="async" style="width:140px;border-radius:12px"></div>`;
                if (m.audio) inner += `<div><audio controls preload="none" src="${m.audio}"></audio></div>`;
                if (m.reaction) inner += `<div class="reaction">${m.reaction}</div>`;
                inner += `<div class="bubble-meta">${new Date(m.time || Date.now()).toLocaleTimeString()}</div>`;
                inner += `</div>`;
                div.innerHTML = (m.from === currentUser) ? inner + avatarTag(m.from) : avatarTag(m.from) + inner;
                messagesEl.appendChild(div);
                // auto scroll if near bottom
                const nearBottom = (messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight) < 150;
                if (nearBottom) messagesEl.scrollTo({ top: messagesEl.scrollHeight, behavior: 'smooth' });
            }

            // Avatars use lazy + decoding
            function avatarTag(name) { const s = esc(name || ''); return `<div class="bubble-avatar"><img src="${s}.jpg" alt="${s}" loading="lazy" decoding="async" onerror="this.style.display='none'"></div>`; }

            // --------------- Utilities ---------------
            async function ensureFireReady() {
                const start = Date.now();
                while (!fire() || !fire().db) {
                    if (Date.now() - start > 3000) break;
                    await new Promise(r => setTimeout(r, 50));
                }
            }

            // --------------- expose for debug ---------------
            window._chatOpt = { sendMessage, selectRoom };

            // initial focus
            passwordInput.focus();

            // click outside hides sticker panel
            document.addEventListener('click', (e) => {
                if (stickerPanel.style.display === 'block') {
                    if (!stickerPanel.contains(e.target) && !btnSticker.contains(e.target)) hideStickers();
                }
            });

            // done
        })();
    </script>
</body>

</html>